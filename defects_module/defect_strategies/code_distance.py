"""
Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.  

SPDX-License-Identifier: CC-BY-NC-4.0
"""

from __future__ import annotations

import itertools

import networkx

from defects_module.base import (
    PauliT,
    Pos,
    SuperStabilizer,
)

from .make_windows import Window
from .snakes_and_ladders import TriangularCheck


def create_ancilla_graph(
    efficient_strategy: list[TriangularCheck],
    superstabilizers: list[SuperStabilizer],
    ancillas: set[Pos],
    boundaries: tuple[list[Pos], list[Pos]],
) -> networkx.classes.graph.Graph:
    """Helper function that creates a weighted subgraph of the
    full detector graph from a list of efficient checks, a list
    of superstabilizers, a list of the ancillas, and the two sets
    of data qubits along the deformed boundaries.

    The nodes of the detector subgraph are the ancillas in
    the superstabilizers, and the data qubits on the deformed
    boundaries. We only add those data qubits to correctly
    capture the distance loss from the boundary deformation.

    We do not include the virtual boundary nodes in the graph
    at this point.

    The weights between the nodes are the shortest Chebyshev
    distance between them in the full detector graph.

    Input arguments:
        `efficient_strategy`: A list of all efficient checks
        (`TriangularCheck` objects) in the patch.
        `superstabilizers`: A list of all superstabilizers in
        the patch that are of the Pauli type opposite to the
        that of the logicals for which the distances are being
        computed.
        `ancillas`: A set of all ancillas in the patch which
        are used in the stabilizers of the undamaged patch to
        measure stabilizers of the same Pauli type as that of
        `superstabilizers`.
        `boundaries`: A tuple of two lists of Pos, one for
        each boundary that is perpendicular to the logicals
        for which the distances are being computed. Here we
        only need to pass the qubits along the boundaries that
        are not part of the *non-deformed* or initial boundaries.

    Output arguments:
        A networkx graph whose vertices are the ancilla qubits
        in the superstabilizers and the data qubits on the
        deformed boundaries.
    """
    # Detector graph
    graph = networkx.Graph()

    # Add weight-0 edges for superstabilizers:
    # Here we add an edge between each pair of ancillas
    # inside the same superstabilizer
    graph.add_edges_from(
        [
            (a1, a2)
            for superstabilizer in superstabilizers
            for a1, a2 in itertools.combinations(superstabilizer.ancilla, r=2)
        ],
        weight=0.0,
    )

    # Add weight-0 edges for the efficient checks:
    # here we add an edge between the repurposed
    # ancilla (check.ancilla) and the ancilla defect
    # (check.ancilla_replaced) for each efficient check
    graph.add_edges_from(
        [
            (check.ancilla, check.ancilla_replaced)
            for check in efficient_strategy
            if check.ancilla_replaced in ancillas
        ],
        weight=0.0,
    )

    # Add data qubits on the deformed boundaries that are not
    # on the edges of the patch: we do not need to include the data qubits
    # on the boundaries of an undamaged patch for example.
    boundary_nodes = [qubit for boundary in boundaries for qubit in boundary]
    graph.add_nodes_from(boundary_nodes)

    # Connect clusters together
    # This approach is faster than adding all qubits in the patch because of the path finding
    # (dijkstra) algorithm used below. We create all possible pairs of nodes
    # in the detector graph and we will compute the distance between them.
    for node1, node2 in itertools.combinations(graph.nodes, r=2):
        if (
            (node1, node2) not in graph.edges
            and node1 in ancillas | set(boundary_nodes)
            and node2 in ancillas | set(boundary_nodes)
        ):
            graph.add_edge(
                node1, node2, weight=max(abs(node2.x - node1.x), abs(node2.y - node1.y)) / 2
            )

    return graph


def compute_distance(
    graph: networkx.classes.graph.Graph,
    detectors: list[Pos],
    virtual_boundary_nodes: list[str],
    boundaries: tuple[list[Pos], list[Pos]],
    lims: tuple[int, int],
    coord: str,
) -> int:
    """Helper function that computes the shortest distance in a the detector graph
    between the two boundaries.

    Here we add the virtual boundary nodes and connect them to the nodes in the detector
    subgraph generated by `create_ancilla_graph`.

    We use the dijkstra algorithm to compute the shortest path length.

    Input arguments:
        `graph`: A networkx graph whose vertices are the ancilla qubits
        in the superstabilizers and the data qubits on the deformed boundaries.
        The edges between the nodes have weights corresponding to the shortest
        Chebyshev distance between them.
        `detectors`: A list of all ancillas in the graph that are NOT repurposed
        ancillas, and all the data qubits that are now part of the boundaries due
        to boundary deformation.
        `virtual_boundary_nodes`: A list of labels for the two virtual boundary
        nodes associated with the two boundaries the logicals (for which we compute
        the distance) touch.
        `boundaries`: A pair of list of Pos corresponding to the two boundaries
        the logicals (for which we compute the distance) touch. Here we only need
        to pass the data qubits that are not part of the *non-deformed* or initial
        boundaries of the patch.
        `lims`: The limits of the window in which lives the patch.
        `coord`: The coordinate (`x` or `y`) identifying if the logicals run
        horizontal (x) or vertical (y).

    Output arguments:
        An integer corresponding to the distance of the shortest logical.
    """
    if not graph.nodes:
        # If there are no superstabilizer there is no node in the graph and
        # therefore we just directly connect the boundary nodes:
        # the horizontal distance is unaltered and maximized.
        graph.add_edge(
            virtual_boundary_nodes[0], virtual_boundary_nodes[1], weight=(lims[1] - lims[0]) / 2
        )
        return int((lims[1] - lims[0]) / 2)

    for node in detectors:
        # We connect all nodes to the boundary nodes with
        # weights corresponding to the shortest distance to them.
        graph.add_edge(virtual_boundary_nodes[0], node, weight=(getattr(node, coord) - lims[0]) / 2)
        graph.add_edge(virtual_boundary_nodes[1], node, weight=(lims[1] - getattr(node, coord)) / 2)

    # Adjust boundary by adding data qubits on the code boundary that are not on the window boundary
    for virtual_boundary_node, boundary in zip(virtual_boundary_nodes, boundaries, strict=True):
        for qubit in boundary:
            graph.add_edge(virtual_boundary_node, qubit, weight=0.5)

    # We compute the horizontal distance by finding the weight of the shortest path
    # in the horizontal distance graph
    return int(
        networkx.dijkstra_path_length(
            graph, virtual_boundary_nodes[0], virtual_boundary_nodes[1], weight="weight"
        )
    )


def compute_effective_distance(
    window: Window,
    efficient_strategy: list[TriangularCheck],
    x_superstabilizers: list[SuperStabilizer],
    z_superstabilizers: list[SuperStabilizer],
    boundaries: dict[str, list[Pos]],
) -> tuple[tuple[int, int], networkx.classes.graph.Graph, networkx.classes.graph.Graph]:
    """Function that computes the effective distance of the deformed patch from detector graphs,
    given lists of the efficient checks used and superstabilizers. The `effective' distance
    (which is the length of the shortest logical in each direction) is based on the detector graphs
    with the detectors of same type connected to a pair of virtual boundary nodes on opposite sides
    in the direction of the logical of opposite type. The effective distance also depends on how
    the boundary is deformed. Here we include this deformation by adding the data qubits on the
    deformed boundary to the graphs and attach them to the virtual boundary nodes such that we can
    correctly include the distance drop between the virtual boundary nodes and the detectors.

    Input arguments:
        `window`: A `Window` object containing information about the initial window.
        `efficient_strategy`: A list of efficient checks (`TriangularCheck` objects).
        `x_superstabilizers`: A list of X type superstabilizers in the patch.
        `z_superstabilizers`: A list of Z type superstabilizers in the patch.
        `boundaries`: A dictionary with 'left', 'bottom', 'right', 'top' as keys and
        a list of Pos (data qubits) corresponding to each of the boundaries.

    Output arguments:
        A tuple containing
        1. The effective code distance as a tuple of two integers.
        2. A networkx graph used to compute the horizontal distance.
        3. A networkx graph used to compute the vertical distance.
    """
    # Determine which corners have been moved
    # first we get the corners of the deformed patch
    deformed_corners: set[Pos] = set()
    deformed_corners |= set(boundaries["left"]) & set(boundaries["bottom"])
    deformed_corners |= set(boundaries["bottom"]) & set(boundaries["right"])
    deformed_corners |= set(boundaries["right"]) & set(boundaries["top"])
    deformed_corners |= set(boundaries["top"]) & set(boundaries["left"])
    # second we get the corners of the initial patch
    initial_corners = {
        Pos(window.xlims[0] + 1, window.ylims[0] + 1),
        Pos(window.xlims[1] - 1, window.ylims[0] + 1),
        Pos(window.xlims[1] - 1, window.ylims[1] - 1),
        Pos(window.xlims[0] + 1, window.ylims[1] - 1),
    }
    # we only keep the deformed corners
    deformed_corners -= initial_corners
    # Extract the data qubits from the boundary that are part of a local
    # deformation, i.e. data qubits that are not part of the non-deformed
    # (initial) boundaries of the patch: this means that the qubit is either
    # NOT on the boundary of the window OR is a deformed corner.
    clean_boundaries = boundaries.copy()
    for label, qubits in boundaries.items():
        # check that the qubit is a data qubit that is not the window boundary
        _qubits = set(
            qubit for qubit in qubits if not window.on_boundary(qubit) or qubit in deformed_corners
        )
        clean_boundaries[label] = list(_qubits)
    # X-type detector graph
    boundary_pairs = [
        (clean_boundaries["left"], clean_boundaries["right"]),
        (clean_boundaries["bottom"], clean_boundaries["top"]),
    ]
    x_graph = create_ancilla_graph(
        efficient_strategy,
        x_superstabilizers,
        window.x_ancillas,
        boundary_pairs[window.vertical_logical == PauliT.Z],
    )
    # Z-type detector graph
    z_graph = create_ancilla_graph(
        efficient_strategy,
        z_superstabilizers,
        window.z_ancillas,
        boundary_pairs[window.vertical_logical == PauliT.X],
    )

    # Determine graphs for horizontal and vertical distances
    boundary_nodes = {q for qs in clean_boundaries.values() for q in qs}
    if window.vertical_logical == PauliT.X:
        horizontal_distance_graph, vertical_distance_graph = x_graph, z_graph
        horizontal_distance_detectors = [
            node for node in x_graph.nodes if node in window.x_ancillas or node in boundary_nodes
        ]
        vertical_distance_detectors = [
            node for node in z_graph.nodes if node in window.z_ancillas or node in boundary_nodes
        ]
    elif window.vertical_logical == PauliT.Z:
        horizontal_distance_graph, vertical_distance_graph = z_graph, x_graph
        horizontal_distance_detectors = [
            node for node in z_graph.nodes if node in window.z_ancillas or node in boundary_nodes
        ]
        vertical_distance_detectors = [
            node for node in x_graph.nodes if node in window.x_ancillas or node in boundary_nodes
        ]
    else:
        raise ValueError("Unexpected vertical logical type.")

    # We compute the horizontal distance
    horizontal_distance = compute_distance(
        horizontal_distance_graph,
        horizontal_distance_detectors,
        ["L", "R"],
        (clean_boundaries["left"], clean_boundaries["right"]),
        window.xlims,
        "x",
    )
    # We compute the horizontal distance
    vertical_distance = compute_distance(
        vertical_distance_graph,
        vertical_distance_detectors,
        ["B", "T"],
        (clean_boundaries["bottom"], clean_boundaries["top"]),
        window.ylims,
        "y",
    )

    return (
        (horizontal_distance, vertical_distance),
        horizontal_distance_graph,
        vertical_distance_graph,
    )
